preprocess(Query &) has to be right after count++ to avoid the case that a comper deletes tc, probably a later comper
cannot find end_mtx in q.

round robin refill + Early Termination
    bool refill_Q()
    {   
        vector<TempTask> tmp_vector;

        Pattern *pattern = tc->pattern;

        tc->refill_mtx.lock();
        if(!tc->nothing_to_refill()) // still got something, do round robin or sequential
        {
            VertexID next_vq = tc->next_vq;

            while(tmp_vector.size() < MINI_BATCH_NUM)
            {

                /**
                 * ====== Early Termination ======
                 * every time we refill, we check next_vq has >=support matches
                 * if yes, do not refill anymore
                 *     1. update next_domainPos[v_q] to end
                 *     2. update domain_finished += # skip nodes
                 * otherwise, keep refilling
                 */

                if(tc->next_domainPos[next_vq] < pattern->get_cands()[next_vq].size())
                {   
                    tc->domain_matches_mtx[next_vq].lock();
                    if(tc->domain_matches[next_vq].size() >= grami.nsupport_)
                    {   
                        // temporary solution: always spawn one task to trigger postprocess(.)
                        // otherwise, this pattern might hang in the queue since no thread would delete it
                        // e.g. cand=[0,1,2,3,4], next_vq=2, #skip = 2 = 5-2-1

                        tc->domain_matches_mtx[next_vq].unlock();

                        // cout << "SKIP" << endl;
                        ui skip_nodes = pattern->get_cands()[next_vq].size() - tc->next_domainPos[next_vq] - 1;

                        tc->next_domainPos[next_vq] = pattern->get_cands()[next_vq].size()-1;

                        tc->end_mtx.lock();
                        tc->domain_finished[next_vq] += skip_nodes;
                        tc->end_mtx.unlock();
                    }
                    else
                    {
                        tc->domain_matches_mtx[next_vq].unlock();
                    }
                }

                VertexID & idx = tc->next_domainPos[next_vq];
                Domain & vq_candidates = pattern->get_cands()[next_vq];
                if(idx < vq_candidates.size())
                {
                    TempTask t(next_vq, vq_candidates[idx], idx);
                    tmp_vector.push_back(t);

                    // update
                    idx++;
                    if(idx == vq_candidates.size())
                    {
                        tc->refill_done ++;
                    }
                }

                if(tc->nothing_to_refill())
                    break;

                // update
                next_vq = (next_vq + 1) % pattern->size();
            }

            tc->next_vq = next_vq;
        }
        tc->refill_mtx.unlock();

        for(ui i = 0; i < tmp_vector.size(); ++i)
        {   
            task_spawn(tmp_vector[i].uid, tmp_vector[i].vid, tmp_vector[i].v_idx);
        }

        if(tmp_vector.size() > 0) 
            return true;
        else 
            return false;
    }